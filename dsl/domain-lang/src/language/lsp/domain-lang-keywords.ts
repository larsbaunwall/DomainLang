export const keywordExplanations: Record<string, string> = {
    Domain: "**Domain**\n\nA Domain represents a sphere of knowledge, influence, or activity. In DDD, it is the subject area to which the user applies a program.\n\n---\n\n*Example: Sales, Shipping, Accounting.*",
    BoundedContext: "**Bounded Context**\n\nA Bounded Context defines the boundary within which a particular domain model is defined and applicable. It is a central pattern in DDD for managing complexity.\n\n---\n\n*Example: SalesContext, SupportContext.*",
    package: "**package**\n\nA package is a namespace for organizing related elements and avoiding naming collisions. Packages can be nested and imported.",
    import: "**import**\n\nImports types or packages from another file or module, enabling reuse and modularity.",
    implements: "**implements**\n\nDeclares that a Bounded Context or type implements a Domain or interface.",
    classifiers: "**classifiers**\n\nA block for listing domain classifications, such as Entity, ValueObject, Aggregate, etc.",
    terminology: "**terminology**\n\nA block for defining ubiquitous language terms and their meanings within a Bounded Context.",
    ContextMap: "**Context Map**\n\nA Context Map visualizes and documents the relationships between Bounded Contexts, including their integration patterns.",
    DomainMap: "**Domain Map**\n\nA Domain Map visualizes and documents the relationships between Domains.",
    Relationship: "**Relationship**\n\nDefines a connection between two Bounded Contexts or Domains, such as Partnership, Customer-Supplier, etc.",
    Role: "**Role**\n\nA named responsibility or function within a context, such as Upstream, Downstream, Partner, etc.",
    Policy: "**Policy**\n\nA business rule or guideline that governs behavior within a context.",
    Decision: "**Decision**\n\nA documented choice or rule that affects the model or process.",
    BusinessRule: "**Business Rule**\n\nA specific rule that constrains or influences business behavior.",
    Entity: "**Entity**\n\nA domain object with a distinct identity that runs through time and different states.",
    ValueObject: "**Value Object**\n\nAn object that describes some characteristic or attribute but has no conceptual identity.",
    Aggregate: "**Aggregate**\n\nA cluster of domain objects that can be treated as a single unit. An aggregate has a root and a boundary.",
    Service: "**Service**\n\nA stateless operation or domain logic that does not naturally fit within an Entity or Value Object.",
    Event: "**Event**\n\nA significant occurrence or change in state that is relevant to the domain.",
    This: "**this**\n\nRefers to the current context or object.",
    as: "**as**\n\nUsed for aliasing or renaming imports or types.",
    from: "**from**\n\nSpecifies the source module or file for an import statement.",
    type: "**type**\n\nDeclares a new type or alias in the model.",
    map: "**map**\n\nDefines a mapping or transformation between elements.",
    // Add more as needed
    ACL: "**ACL (Anti-Corruption Layer)**\n\nA defensive pattern that creates a translation layer between two bounded contexts to prevent concepts from one context polluting the other.\n\n---\n\n*Example: A layer that translates legacy system data formats into modern domain models.*",
    OHS: "**OHS (Open Host Service)**\n\nA protocol or interface that provides access to a subsystem as a set of services, making integration easier for other contexts.\n\n---\n\n*Example: A well-documented REST API that other contexts can consume.*",
    PL: "**PL (Published Language)**\n\nA well-documented shared language that helps multiple contexts communicate. Often used with Open Host Service.\n\n---\n\n*Example: A standardized XML schema or JSON format for data exchange.*",
    CF: "**CF (Conformist)**\n\nA pattern where a downstream team fully adopts the model of the upstream team, without translation.\n\n---\n\n*Example: A new service that exactly matches the data model of an existing system.*",
    BBoM: "**BBoM (Big Ball of Mud)**\n\nA system with little or no perceivable architecture, typically resulting from rapid growth without architectural governance.\n\n---\n\n*Example: A monolithic application with tangled dependencies and no clear boundaries.*",
    SK: "**SK (Shared Kernel)**\n\nA subset of the domain model that is shared between multiple bounded contexts and maintained in close coordination.\n\n---\n\n*Example: Common data structures shared between Sales and Billing contexts.*",
    P: "**P (Partnership)**\n\nA relationship where two teams succeed or fail together, requiring close collaboration and shared goals.\n\n---\n\n*Example: Two teams jointly developing interconnected features.*",
    SeparateWays: "**Separate Ways**\n\nA relationship pattern where two contexts decide to have no connection, each solving similar problems differently.\n\n---\n\n*Example: Different departments maintaining separate customer databases.*",
    Partnership: "**Partnership**\n\nA relationship where teams share both risks and rewards, requiring close collaboration and joint decision-making.\n\n---\n\n*Example: Two teams working together on a critical business capability.*",
    SharedKernel: "**Shared Kernel**\n\nA pattern where multiple bounded contexts share a common subset of the domain model, requiring careful coordination for changes.\n\n---\n\n*Example: Common validation rules shared across multiple contexts.*",
    CustomerSupplier: "**Customer-Supplier**\n\nA relationship where the upstream team prioritizes the downstream team's needs, but still maintains independence.\n\n---\n\n*Example: An API team prioritizing features needed by consuming teams.*",
    UpstreamDownstream: "**Upstream-Downstream**\n\nA relationship where changes in the upstream context can affect the downstream context, but not vice versa.\n\n---\n\n*Example: A core service (upstream) used by multiple dependent services (downstream).*",
}; 
