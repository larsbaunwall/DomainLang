// ============================================================================
// Multi-Reference Demonstration - DomainLang Example
// ============================================================================
// This example demonstrates how DomainLang handles references when multiple
// elements share the same name across different scopes or namespaces.
//
// Multi-references allow you to:
// 1. Model the same concept from different team perspectives
// 2. Aggregate contexts/domains that share names from imports
// 3. Create flexible, modular domain architectures

// ============================================================================
// Example 1: Same BC name in different domains
// ============================================================================

Domain Sales {
    description: "Sales operations and customer acquisition"
}

Domain Support {
    description: "Customer support and service"
}

// Sales team's perspective of customer management
bc CustomerManagement for Sales {
    description: "Sales team's view: leads, opportunities, deals"
    
    terminology {
        term Lead: "Potential customer prospect"
        term Opportunity: "Qualified sales opportunity"
        term Deal: "Active sales negotiation"
    }
}

// Support team's perspective of customer management
bc CustomerManagement for Support {
    description: "Support team's view: tickets, SLAs, escalations"
    
    terminology {
        term Ticket: "Customer support request"
        term SLA: "Service level agreement"
        term Escalation: "Elevated priority issue"
    }
}

// ContextMap can reference BOTH CustomerManagement contexts
ContextMap CustomerServices {
    contains CustomerManagement
}

// ============================================================================
// Example 2: Namespaced organization
// ============================================================================

Namespace Ecommerce {
    Classification CoreDomain
    Classification SupportingDomain
    
    Domain Catalog {
        description: "Product catalog and inventory"
    }
    
    Domain Orders {
        description: "Order processing and fulfillment"
    }
    
    bc ProductSearch for Catalog as CoreDomain {
        description: "Search and browse products"
        
        terminology {
            term Product: "Item available for purchase"
            term SearchIndex: "Indexed product data for fast search"
        }
    }
    
    bc OrderProcessing for Orders as CoreDomain {
        description: "Process and fulfill customer orders"
        
        terminology {
            term Order: "Customer purchase request"
            term OrderLine: "Individual item in an order"
        }
    }
    
    ContextMap WebStore {
        contains ProductSearch, OrderProcessing
        ProductSearch -> OrderProcessing
    }
}

Namespace Payments {
    Classification GenericDomain
    
    Domain Billing {
        description: "Payment processing"
    }
    
    bc PaymentGateway for Billing as GenericDomain {
        description: "Process payments via external providers"
        
        terminology {
            term PaymentIntent: "Initiated payment request"
            term PaymentConfirmation: "Successful payment response"
        }
    }
}

// Cross-namespace references using qualified names
ContextMap FullEcommerceExperience {
    contains Ecommerce.ProductSearch, Ecommerce.OrderProcessing, Payments.PaymentGateway
    
    Ecommerce.OrderProcessing -> Payments.PaymentGateway
}

// ============================================================================
// Example 3: Strategic classifications across layers
// ============================================================================

Classification Core
Classification Supporting
Classification Generic

Domain Ordering {
    description: "Order management domain"
}

Team OrderTeam
Team NotificationTeam

bc OrderProcessing for Ordering as Core by OrderTeam {
    description: "Core order workflow"
    
    terminology {
        term Order: "Customer purchase request"
        term OrderState: "Current state of order"
            examples: "Pending", "Confirmed", "Shipped", "Delivered"
    }
}

bc OrderValidation for Ordering as Supporting by OrderTeam {
    description: "Order validation rules"
    
    terminology {
        term ValidationRule: "Rule for checking order validity"
        term ValidationError: "Order validation failure"
    }
}

bc OrderNotifications for Ordering as Generic by NotificationTeam {
    description: "Generic notification service"
    
    terminology {
        term Notification: "Message sent to customer"
        term NotificationChannel: "Delivery method"
            examples: "Email", "SMS", "Push"
    }
}

ContextMap OrderingPlatform {
    contains OrderProcessing, OrderValidation, OrderNotifications
    
    OrderProcessing -> OrderValidation
    OrderProcessing -> OrderNotifications
}

// ============================================================================
// Example 4: Domain maps across business units
// ============================================================================

Domain SalesDomain {
    description: "Sales domain"
    classification: Core
}

Domain Marketing {
    description: "Marketing domain"
    classification: Supporting
}

Domain CustomerSupport {
    description: "Support domain"
    classification: Supporting
}

DomainMap CustomerFacingDomains {
    contains SalesDomain, Marketing, CustomerSupport
}

// ============================================================================
// Key Takeaways
// ============================================================================
// 
// 1. Multi-references enable MODULAR ARCHITECTURE:
//    Different teams can define their version of a BC/Domain in separate files,
//    and you can reference all of them in aggregate views.
//
// 2. Use NAMESPACES for organization:
//    Avoid name collisions by organizing related elements in namespaces.
//    Use qualified names (e.g., Ecommerce.ProductSearch) for precise references.
//
// 3. STRATEGIC FLEXIBILITY:
//    Model the same concept from multiple perspectives (Sales view vs Support view)
//    and create unified views that aggregate all perspectives.
//
// 4. IMPORT-FRIENDLY:
//    When importing multiple files with overlapping names, references resolve
//    to all matching instances instead of causing errors.
//
// 5. DISTRIBUTED MODELING:
//    Large organizations can split modeling across teams and files, then
//    compose comprehensive views using multi-references.
