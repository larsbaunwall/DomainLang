// ============================================================================
// Multi-Reference Demonstration - DomainLang Example
// ============================================================================
// This example demonstrates how DomainLang handles references when multiple
// elements share the same name across different scopes or namespaces.
//
// Multi-references allow you to:
// 1. Model the same concept from different team perspectives
// 2. Aggregate contexts/domains that share names from imports
// 3. Create flexible, modular domain architectures
// ============================================================================

// ============================================================================
// Example 1: Same BC name in different domains
// ============================================================================
// Different teams can model "CustomerManagement" from their perspective

Domain Sales:
    description: "Sales operations and customer acquisition"

Domain Support:
    description: "Customer support and service"

// Sales team's perspective of customer management
BC CustomerManagement:
    for: Sales
    description: "Sales team's view: leads, opportunities, deals"
    
    terminology:
        - Lead: "Potential customer prospect"
        - Opportunity: "Qualified sales opportunity"
        - Deal: "Active sales negotiation"

// Support team's perspective of customer management
BC CustomerManagement:
    for: Support
    description: "Support team's view: tickets, SLAs, escalations"
    
    terminology:
        - Ticket: "Customer support request"
        - SLA: "Service level agreement"
        - Escalation: "Elevated priority issue"

// ContextMap can reference BOTH CustomerManagement contexts
// When you reference "CustomerManagement", it resolves to both instances
ContextMap CustomerServices:
    contains:
        - CustomerManagement

// ============================================================================
// Example 2: Namespaced organization with qualified names
// ============================================================================

namespace Ecommerce:
    Classification CoreDomain
    Classification SupportingDomain

    Domain Catalog:
        description: "Product catalog and inventory"

    Domain Orders:
        description: "Order processing and fulfillment"

    BC ProductSearch:
        for: Catalog
        as: CoreDomain
        description: "Search and browse products"
        
        terminology:
            - Product: "Item available for purchase"
            - SearchIndex: "Indexed product data for fast search"

    BC OrderProcessing:
        for: Orders
        as: CoreDomain
        description: "Process and fulfill customer orders"
        
        terminology:
            - Order: "Customer purchase request"
            - OrderLine: "Individual item in an order"

    // ContextMap within namespace
    ContextMap WebStore:
        contains:
            - ProductSearch
            - OrderProcessing
        relationships:
            - ProductSearch -> OrderProcessing

namespace Payments:
    Classification GenericDomain

    Domain Billing:
        description: "Payment processing"

    BC PaymentGateway:
        for: Billing
        as: GenericDomain
        description: "Process payments via external providers"
        
        terminology:
            - PaymentIntent: "Initiated payment request"
            - PaymentConfirmation: "Successful payment response"

// Cross-namespace references using qualified names
ContextMap FullEcommerceExperience:
    contains:
        - Ecommerce.ProductSearch
        - Ecommerce.OrderProcessing
        - Payments.PaymentGateway
    relationships:
        - Ecommerce.OrderProcessing -> Payments.PaymentGateway

// ============================================================================
// Example 3: Strategic classifications across layers
// ============================================================================

Classification Core
Classification Supporting
Classification Generic

Domain Ordering:
    description: "Order management domain"

Team OrderTeam
Team NotificationTeam

// Different bounded contexts with strategic classifications
BC OrderProcessing:
    for: Ordering
    as: Core
    by: OrderTeam
    description: "Core order workflow"
    
    terminology:
        - Order: "Customer purchase request"
        - OrderState: "Current state of order"
            examples: "Pending", "Confirmed", "Shipped", "Delivered"

BC OrderValidation:
    for: Ordering
    as: Supporting
    by: OrderTeam
    description: "Order validation rules"
    
    terminology:
        - ValidationRule: "Rule for checking order validity"
        - ValidationError: "Order validation failure"

BC OrderNotifications:
    for: Ordering
    as: Generic
    by: NotificationTeam
    description: "Generic notification service"
    
    terminology:
        - Notification: "Message sent to customer"
        - NotificationChannel: "Delivery method"
            examples: "Email", "SMS", "Push"

// ContextMap aggregates all order-related contexts
ContextMap OrderingPlatform:
    contains:
        - OrderProcessing
        - OrderValidation
        - OrderNotifications
    relationships:
        - OrderProcessing -> OrderValidation
        - OrderProcessing -> OrderNotifications

// Strategic grouping by classification
ContextGroup CoreOrderingCapabilities:
    for: Ordering
    role: Core
    contains:
        - OrderProcessing

// ============================================================================
// Example 4: Import scenarios (conceptual - would work with separate files)
// ============================================================================
// If you had multiple files:
//
// File 1 (sales-context.dlang):
//   Domain Sales: ...
//   BC Reporting:
//       for: Sales
//       ...
//
// File 2 (marketing-context.dlang):
//   Domain Marketing: ...
//   BC Reporting:
//       for: Marketing
//       ...
//
// File 3 (analytics-map.dlang):
//   import "./sales-context.dlang"
//   import "./marketing-context.dlang"
//   
//   ContextMap Analytics:
//       contains:
//           - Reporting  // <- Resolves to BOTH Sales.Reporting and Marketing.Reporting!
//
// This multi-reference behavior allows modular, team-based modeling where
// different teams can independently define their contexts and then aggregate
// them in higher-level architectural views.

// ============================================================================
// Example 5: Domain maps across business units
// ============================================================================

Domain Sales:
    description: "Sales domain"
    classifier: Core

Domain Marketing:
    description: "Marketing domain"
    classifier: Supporting

Domain CustomerSupport:
    description: "Support domain"
    classifier: Supporting

// DomainMap uses references for each domain
DomainMap CustomerFacingDomains:
    contains:
        - Sales
        - Marketing
        - CustomerSupport

// If you import another file with a "Sales" domain in a different namespace,
// references would resolve to all matching domains


// ============================================================================
// Key Takeaways
// ============================================================================
// 
// 1. Multi-references enable MODULAR ARCHITECTURE:
//    Different teams can define their version of a BC/Domain in separate files,
//    and you can reference all of them in aggregate views.
//
// 2. Use NAMESPACES for organization:
//    Avoid name collisions by organizing related elements in namespaces.
//    Use qualified names (e.g., Ecommerce.ProductSearch) for precise references.
//
// 3. STRATEGIC FLEXIBILITY:
//    Model the same concept from multiple perspectives (Sales view vs Support view)
//    and create unified views that aggregate all perspectives.
//
// 4. IMPORT-FRIENDLY:
//    When importing multiple files with overlapping names, references resolve
//    to all matching instances instead of causing errors.
//
// 5. DISTRIBUTED MODELING:
//    Large organizations can split modeling across teams and files, then
//    compose comprehensive views using multi-references.
